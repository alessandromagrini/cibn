# generate random CPTs (internal use only)
randomParams <- function(counts,new.tau=NULL) {
  if(is.null(new.tau)) {
    new.tau <- 1
    theta <- counts
    } else {
    theta <- normalise(counts)
    }
  rdirch <- function(alpha) {
    if(sum(alpha)==0) alpha <- 1/length(alpha)
    auxnam <- names(alpha)
    x <- c()
    for(i in 1:length(alpha)) {
      x[i] <- rgamma(1,alpha[i],1)
      }
    names(x) <- auxnam
    x/sum(x)
    }
  theta <- normalise(counts)
  for(i in 1:length(theta)) {
    idim <- dim(theta[[i]])
    iyd <- idim[1]
    if(length(idim)>1) {
      ixd <- idim[-1]
      mystr <- ""
      for(j in 1:length(ixd)) {
        mystr <- paste(mystr,"for(k",j," in 1:",ixd[j],") {; ",sep="")
        }
      mystr <- paste(mystr,"ijalpha <- counts[[",i,"]][,",paste("k",1:length(ixd),sep="",collapse=","),"]; ",
        "if(isDegen(ijalpha)==F) { theta[[",i,"]][,",paste("k",1:length(ixd),sep="",collapse=","),"] <- rdirch(new.tau*ijalpha) }; ",sep="")
      mystr <- paste(mystr,paste(rep("}",length(ixd)),collapse="; "),sep="")
      eval(parse(text=mystr))
      } else {
      if(isDegen(theta[[i]])==F) {
        theta[[i]][] <- rdirch(new.tau*counts[[i]])
        }
      }
    }
  theta
  }

# check if a distribution is degenerated (internal use only)
isDegen <- function(x) {
  if(sum(x==0)==length(x)-1) T else F
  }

# evidence propagation
query.cibn <- function(x,target=NULL,evidence=NULL,type="marginal",CI=FALSE,conf=0.95,nitt=500) {
  if(!identical(class(x),"cibn")) stop("The first argument must be an object of class 'cibn'",call.=F)
  if(!is.logical(CI)) stop("Argument 'CI' must be logical",call.=F)
  nomi <- getVariables(x)
  if((type %in% c("marginal","joint"))==F) stop("Argument 'type' must be either 'marginal' or 'joint'",call.=F)
  if(length(target)==0) target <- nomi
  unknVar1 <- setdiff(target,names(x$CPTs))
  if(length(unknVar1)>0) {
    warning("Unknown variables in argument 'target' have been ignored: ",paste(unknVar1,collapse=", "),call.=F)
    target <- setdiff(target,unknVar1)
    }
  if(!is.null(evidence) && !is.list(evidence)) stop("Argument 'evidence' must be a list",call.=F)
  unknVar2 <- setdiff(names(evidence),names(x$CPTs))
  if(length(unknVar2)>0) {
    warning("Unknown variable names in argument 'evidence' have been ignored: ",paste(unknVar2,collapse=", "),call.=F)
    evidence <- evidence[setdiff(names(evidence),unknVar2)]
    }
  if(length(evidence)>0) {
    auxdupl <- names(evidence)[duplicated(names(evidence))]
    if(length(auxdupl)>0) stop("Duplicated variable name in argument 'evidence': ",auxdupl[1],call.=F)
    omega <- fullOmega(x$CPTs)
    for(i in 1:length(evidence)) {
      inam <- names(evidence)[i]
      ichk <- setdiff(evidence[[i]],omega[[inam]])
      if(length(ichk)>0) {
        warning("Unknown levels in argument 'evidence' for variable ",inam," have been ignored: ",paste(ichk,collapse=", "),call.=F)
        if(length(evidence)==1) evidence <- NULL
        }
      }
    }
  gnet <- as.grain(x)
  if(CI==F) {
    out <- propFun(gnet,target,evidence,type)
    } else {
    if(conf<=0 || conf>=1) stop("Argument 'conf' must be a number between 0 and 1",call.=F)
    if(nitt<=0 || !identical(nitt,round(nitt))) stop("Invalid number of iterations",call.=F)
    aux.out <- list()
    cat("  |",rep(" ",50),"| 0%",sep="")    
    flush.console()                         
    for(i in 1:nitt) {
      if(is.null(x$posterior)) {
        theta <- randomParams(x$prior)
        } else {
        theta <- randomParams(x$posterior)
        }
      G <- list(CPTs=normalise(theta),prior=theta,posterior=NULL,description=x$description)  
      class(G) <- "cibn"                                   
      ibn <- as.grain(G)
      iout <- propFun(ibn,target,evidence,type)
      aux.out[[i]] <- iout
      indStar <- round(i*50/nitt)
      cat('\r',"  |",rep("*",indStar),rep(" ",50-indStar),"| ",indStar*2,"%",sep="")
      flush.console()                                                                 
      }
    cat("\n")                                                                         
    out.sx <- out.dx <- aux.out[[1]]
    for(i in 1:length(out.sx)) {
      for(j in 1:length(out.sx[[i]])) {    
        p <- c()
        for(w in 1:nitt) { 
          p[w] <- aux.out[[w]][[i]][j]
          }
        out.sx[[i]][j] <- quantile(p,prob=(1-conf)/2)
        out.dx[[i]][j] <- quantile(p,prob=(1+conf)/2)
        }
      }
    out.fit <- propFun(gnet,target,evidence,type)
    if(type=="marginal") {
      out <- list(out.fit[sort(target)],out.sx[sort(target)],out.dx[sort(target)])
      } else {
      out <- list(out.fit,out.sx,out.dx)
      }
    names(out) <- c("estimate",paste(c("lower","upper"),"_",floor(conf*100),"%",sep=""))
    }                        
  out
  }

